/*!
 * Crafted with ❤ by Salla
 */
import { h, Host } from '@stencil/core';
import { DisplayType } from './interfaces';
import CheckCircleIcon from '../../assets/svg/check.svg';
import CameraIcon from '../../assets/svg/camera.svg';
import FileIcon from '../../assets/svg/file-upload.svg';
export class SallaProductOptions {
  constructor() {
    this.fileTypes = {
      pdf: 'application/pdf',
      png: 'image/png',
      jpg: 'image/jpeg',
      word: 'application/doc,application/ms-doc,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      exl: 'application/excel,application/vnd.ms-excel,application/x-excel,application/x-msexcel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      txt: 'text/plain',
    };
    this.outSkus = [];
    this.optionsData = undefined;
    this.outOfStockText = '';
    this.donationAmount = salla.lang.get('pages.products.donation_amount');
    this.selectedOptions = [];
    this.canDisabled = undefined;
    this.selectedSkus = undefined;
    this.selectedOutSkus = undefined;
    this.productId = salla.config.get('page.id');
    this.options = undefined;
    this.canDisabled = !salla.config.get('store.settings.products.notify_options_availability');
    salla.lang.onLoaded(() => {
      this.outOfStockText = salla.lang.get("pages.products.out_of_stock");
      this.donationAmount = salla.lang.get('pages.products.donation_amount');
    });
    if (this.options) {
      try {
        this.setOptionsData(JSON.parse(this.options));
        return;
      }
      catch (e) {
        salla.log('Bad json passed via options prop');
      }
    }
    if (!Array.isArray(this.optionsData)) {
      salla.log('Options is not an array[] ---> ', this.optionsData);
      this.setOptionsData([]);
    }
    if (this.productId && !salla.url.is_page('cart')) {
      salla.api.product.getDetails(this.productId, ['options']).then(resp => this.setOptionsData(resp.data.options));
    }
  }
  setOptionsData(optionsData) {
    var _a, _b;
    this.optionsData = optionsData;
    let that = this;
    (_b = (_a = this.optionsData[0]) === null || _a === void 0 ? void 0 : _a.details) === null || _b === void 0 ? void 0 : _b.forEach(function (detail) {
      Object.entries(detail.skus_availability || {})
        .filter(sku => !sku[1])
        .map(sku => that.outSkus.push(Number(sku[0])));
    });
  }
  /**
   * Get the id's of the selected options.
   * */
  async getSelectedOptionsData() {
    let selectedOptions = {};
    let formData = this.host.getElementSallaData();
    formData.forEach(function (value, key) {
      key.startsWith('options[') && (selectedOptions[key.replace('options[', '').replace(']', '')] = value);
    });
    return selectedOptions;
  }
  /**
   * Report options form validity.
   * */
  async reportValidity() {
    let requiredElements = this.host.querySelectorAll('[required]');
    let pass = true;
    for (let i = 0; i < requiredElements.length; i++) {
      //if there is only one invalid option, return false
      if ('reportValidity' in requiredElements[i] && !requiredElements[i].reportValidity()) {
        pass = false;
      }
    }
    return pass;
  }
  /**
   * Return true if there is any out of stock options are selected and vise versa.
   * */
  async hasOutOfStockOption() {
    return this.selectedOptions.some(option => option.is_out) || (this.selectedSkus.length && this.selectedSkus.every(sku => this.outSkus.includes(sku)));
  }
  /**
   * Get selected options.
   * */
  async getSelectedOptions() {
    return this.selectedOptions;
  }
  /**
   * Get a specific option by its id.
   * */
  async getOption(option_id) {
    return this.optionsData.find(option => option.id === option_id);
  }
  // @ts-ignore
  invalidHandler(event, option) {
    const closestProductOption = event.target.closest('.s-product-options-option');
    if (!salla.url.is_page('cart')) {
      closestProductOption.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    closestProductOption.classList.add('s-product-options-option-error');
  }
  changedHandler(event, option) {
    let data = { event: event, option: option, detail: null };
    if (option.details) {
      let detail = option.details.find((detail) => {
        return Number(detail.id) === Number(event.target.value);
      });
      data.detail = detail;
    }
    let optionElement = event.target.closest('.s-product-options-option');
    if (event.target.value
      || ((option.type == DisplayType.FILE || option.type == DisplayType.IMAGE) && event.type === 'added')
      || (option.type == DisplayType.MAP && event.type === 'selected' && (event.target.lat && event.target.lng))) {
      setTimeout(() => {
        optionElement.classList.remove('s-product-options-option-error');
      }, 200);
    }
    const index = this.selectedOptions.findIndex(option => option.option_id === data.option.id);
    index > -1 ? this.selectedOptions[index] = Object.assign(Object.assign({}, data.detail), { option_id: data.option.id }) : this.selectedOptions.push(Object.assign(Object.assign({}, data.detail), { option_id: data.option.id }));
    this.setSelectedSkus();
    this.handleRequiredMultipleOptions(option);
    this.changed.emit(data);
    salla.event.emit('product-options::change', data);
  }
  /**
   * loop throw all selected details, then get common sku, if it's only one, means we selected all of them;
   */
  setSelectedSkus() {
    this.selectedSkus = this.selectedOptions.map(detail => Object.keys(detail.skus_availability || {}))
      .reduce((p, c) => p.filter(e => c.includes(e)))
      .map(sku => Number(sku));
  }
  handleRequiredMultipleOptions(option) {
    if (option.type !== DisplayType.MULTIPLE_OPTIONS || !option.required) {
      return;
    }
    const optionContainer = this.host.querySelector(`[data-option-id="${option.id}"]`);
    const hasChecked = optionContainer.querySelectorAll('input:checked').length;
    optionContainer.querySelectorAll('input').forEach(input => input.toggleAttribute('required', !hasChecked));
  }
  getLatLng(value, type) {
    return value
      ? value.split(',')[type == 'lat' ? 0 : 1]
      : '';
  }
  getDisplayForType(option) {
    if (this[`${option.type}Option`]) {
      return this[`${option.type}Option`](option);
    }
    if (option.type === DisplayType.COLOR_PICKER) {
      return this.colorPickerOption(option);
    }
    if (option.type === DisplayType.MULTIPLE_OPTIONS) {
      return this.multipleOptions(option);
    }
    if (option.type === DisplayType.SINGLE_OPTION) {
      return this.singleOption(option);
    }
    salla.log(`Couldn't find options type(${option.type})😢`);
    return '';
  }
  getOptionShownWhen(option) {
    return option.visibility_condition
      ? { "data-show-when": `options[${option.visibility_condition.option}] ${option.visibility_condition.operator} ${option.visibility_condition.value}` }
      : {};
  }
  //we need the cart Id for productOption Image
  componentWillLoad() {
    this.outOfStockText = salla.lang.get('pages.products.out_of_stock');
    return salla.api.cart.getCurrentCartId();
  }
  render() {
    var _a;
    if (((_a = this.optionsData) === null || _a === void 0 ? void 0 : _a.length) == 0) {
      return;
    }
    return (h(Host, { class: "s-product-options-wrapper" }, h("salla-conditional-fields", null, this.optionsData.map((option) => h("div", Object.assign({ class: `s-product-options-option-container${option.visibility_condition ? ' hidden' : ''}`, "data-option-id": option.id }, this.getOptionShownWhen(option)), option.name == 'splitter' ?
      this.splitterOption()
      : h("div", { class: "s-product-options-option", "data-option-type": option.type, "data-option-required": `${option.required}` }, h("label", { htmlFor: 'options[' + option.id + ']', class: "s-product-options-option-label" }, h("b", null, option.name, option.required && h("span", null, " * "), " "), h("small", null, option.placeholder)), h("div", { class: "s-product-options-option-content" }, this.getDisplayForType(option))))))));
  }
  //@ts-ignore
  donationOption(option, product) {
    return h("div", { class: "s-product-options-donation-wrapper" }, option.donation ?
      h("div", { class: "s-product-options-donation-progress" }, h("salla-progress-bar", { donation: option.donation }))
      : '', h("div", { class: "s-product-options-donation-input-group" }, h("input", { type: "text", id: "donating-amount", name: "donating_amount", class: "s-form-control", value: option.value, required: true, placeholder: option.placeholder, onInput: e => salla.helpers.inputDigitsOnly(e.target), onBlur: e => this.changedHandler(e, option), onInvalid: (e) => this.invalidHandler(e, option) }), h("span", { class: "s-product-options-donation-amount-currency" }, salla.config.currency(salla.config.get('user.currency_code')).symbol)));
  }
  fileUploader(option, additions = null) {
    return h("salla-file-upload", Object.assign({}, (additions || {}), { "payload-name": "file", value: option.value, "instant-upload": true, name: `options[${option.id}]`, required: option.required, height: "120px", onAdded: (e) => this.changedHandler(e, option), url: salla.cart.api.getUploadImageEndpoint(), "form-data": { cart_item_id: this.productId, product_id: this.productId }, onInvalidInput: (e) => this.invalidHandler(e, option), class: { "s-product-options-image-input": true, required: option.required } }), h("div", { class: "s-product-options-filepond-placeholder" }, h("span", { class: "s-product-options-filepond-placeholder-icon", innerHTML: additions.accept && additions.accept.split(',').every(type => type.includes('image'))
        ? CameraIcon
        : FileIcon }), h("p", { class: "s-product-options-filepond-placeholder-text" }, salla.lang.get('common.uploader.drag_and_drop')), h("span", { class: "filepond--label-action" }, salla.lang.get('common.uploader.browse'))));
  }
  //@ts-ignore
  imageOption(option) {
    return this.fileUploader(option, { accept: 'image/png,image/jpeg,image/jpg,image/gif' });
  }
  //@ts-ignore
  fileOption(option) {
    let types = option.details.map(detail => this.fileTypes[detail.name]).filter(Boolean);
    return (types === null || types === void 0 ? void 0 : types.length)
      ? this.fileUploader(option, { accept: types.join(',') })
      : 'File types not selected.';
  }
  //@ts-ignore
  numberOption(option) {
    return h("input", { type: "text", value: option.value, class: "s-form-control", required: option.required, name: `options[${option.id}]`, placeholder: option.placeholder, onBlur: e => this.changedHandler(e, option), onInvalid: (e) => this.invalidHandler(e, option), onInput: e => salla.helpers.inputDigitsOnly(e.target) });
  }
  //@ts-ignore
  splitterOption() {
    return h("div", { class: "s-product-options-splitter" });
  }
  //@ts-ignore
  textOption(option) {
    return h("div", { class: "s-product-options-text" }, h("input", { type: "text", value: option.value, class: 's-form-control', required: option.required, name: `options[${option.id}]`, placeholder: option.placeholder, onInvalid: (e) => this.invalidHandler(e, option), onInput: e => this.changedHandler(e, option) }));
  }
  //@ts-ignore
  textareaOption(option) {
    //todo::remove mt-1 class, and if it's okay to remove the tag itself will be great
    return h("div", { class: "s-product-options-textarea" }, h("div", { class: "mt-1" }, h("textarea", { rows: 4, value: option.value, class: "s-form-control", required: option.required, id: `options[${option.id}]`, name: `options[${option.id}]`, placeholder: option.placeholder, onInvalid: (e) => this.invalidHandler(e, option), onInput: (e) => this.changedHandler(e, option) })));
  }
  //@ts-ignore
  mapOption(option) {
    return h("salla-map", { zoom: 15, lat: this.getLatLng(option.value, 'lat'), lng: this.getLatLng(option.value, 'lng'), name: `options[${option.id}]`, searchable: true, required: option.required, onInvalidInput: (e) => this.invalidHandler(e, option), onSelected: e => this.changedHandler(e, option) });
  }
  colorPickerOption(option) {
    return h("salla-color-picker", { onSubmitted: e => this.changedHandler(e, option), name: `options[${option.id}]`, required: option.required, onInvalidInput: (e) => this.invalidHandler(e, option), color: option.value });
  }
  /**
   * ============= Date Time options =============
   */
  //@ts-ignore
  timeOption(option) {
    return h("salla-datetime-picker", { noCalendar: true, enableTime: true, dateFormat: "h:i K", value: option.value, placeholder: option.name, required: option.required, name: `options[${option.id}]`, class: "s-product-options-time-element", onInvalidInput: (e) => this.invalidHandler(e, option), onPicked: e => this.changedHandler(e, option) });
  }
  //@ts-ignore
  dateOption(option) {
    //todo:: consider date-range @see https://github.com/SallaApp/theme-raed/blob/master/src/assets/js/partials/product-options.js#L8-L23
    return h("div", { class: "s-product-options-date-element" }, h("salla-datetime-picker", { value: option.value, placeholder: option.name, required: option.required, minDate: new Date(), name: `options[${option.id}]`, onInvalidInput: (e) => this.invalidHandler(e, option), onPicked: e => this.changedHandler(e, option) }));
  }
  //@ts-ignore
  datetimeOption(option) {
    //todo:: consider date-range @see https://github.com/SallaApp/theme-raed/blob/master/src/assets/js/partials/product-options.js#L8-L23
    return h("div", { class: "s-product-options-datetime-element" }, h("salla-datetime-picker", { enableTime: true, value: option.value, dateFormat: "Y-m-d G:i:K", placeholder: option.name, required: option.required, name: `options[${option.id}]`, maxDate: option.to_date_time, minDate: option.from_date_time, onInvalidInput: (e) => this.invalidHandler(e, option), onPicked: e => this.changedHandler(e, option) }));
  }
  /**
   * ============= Advanced options =============
   */
  getOptionDetailName(detail, outOfStock = true, optionType) {
    if (optionType && optionType == DisplayType.COLOR) {
      return detail.name
        + ((outOfStock && this.isOptionDetailOut(detail)) ? ` <br/> <p> ${this.outOfStockText} </p>` : '')
        + (detail.additional_price ? ` <p> (${salla.money(detail.additional_price)}) </p>` : '');
    }
    return detail.name
      + ((outOfStock && this.isOptionDetailOut(detail)) ? ` - ${this.outOfStockText}` : '')
      + (detail.additional_price ? ` (${salla.money(detail.additional_price)})` : '');
  }
  isOptionDetailOut(detail) {
    var _a;
    if (detail.is_out || !detail.skus_availability || !((_a = this.selectedSkus) === null || _a === void 0 ? void 0 : _a.length)) {
      return detail.is_out;
    }
    let isDetailSelected = this.selectedOptions.filter(option => option.id == detail.id).length;
    //if the current options is the only selected option, so we are sure that it's not out, because there is no other options selected yet
    if (isDetailSelected && this.selectedOptions.length == 1) {
      return false;
    }
    //if current details has sku in the possible outSkus it's out for sure
    if (isDetailSelected) {
      //here we will get the possible outSkus for current selected options
      let outSelectableSkus = this.selectedSkus.filter(sku => this.outSkus.includes(sku));
      return Object.keys(detail.skus_availability).some(sku => outSelectableSkus.includes(Number(sku)));
    }
    return this.selectedOptions.some(option => option.is_out && option.option_id !== detail.option_id);
  }
  singleOption(option) {
    return h("div", null, h("select", { name: `options[${option.id}]`, required: option.required, class: "s-form-control", onInvalid: (e) => this.invalidHandler(e, option), onChange: e => this.changedHandler(e, option) }, h("option", { value: "" }, option.placeholder), option === null || option === void 0 ? void 0 :
      option.details.map((detail) => {
        return h("option", { value: detail.id, disabled: this.canDisabled && this.isOptionDetailOut(detail), selected: detail.is_selected }, this.getOptionDetailName(detail));
      })));
  }
  multipleOptions(option) {
    return h("div", { class: { "s-product-options-multiple-options-wrapper": true, 'required': option.required } }, option === null || option === void 0 ? void 0 : option.details.map((detail) => {
      return h("div", null, h("input", { type: "checkbox", value: detail.id, disabled: this.isOptionDetailOut(detail), checked: detail.is_selected, required: option.required, name: `options[${option.id}][]`, id: `field-${option.id}-${detail.id}`, onChange: (e) => this.changedHandler(e, option), onInvalid: (e) => this.invalidHandler(e, option), "aria-describedby": `options[${option.id}]-description` }), h("label", { htmlFor: `field-${option.id}-${detail.id}` }, this.getOptionDetailName(detail)));
    }));
  }
  //@ts-ignore
  colorOption(option) {
    return h("fieldset", { class: "s-product-options-colors-wrapper" }, option === null || option === void 0 ? void 0 : option.details.map((detail) => h("div", { class: "s-product-options-colors-item" }, h("input", { type: "radio", value: detail.id, required: option.required, checked: detail.is_selected, name: `options[${option.id}]`, disabled: this.canDisabled && this.isOptionDetailOut(detail), id: `color-${this.productId}-${option.id}-${detail.id}`, onInvalid: (e) => this.invalidHandler(e, option), onChange: e => this.changedHandler(e, option) }), h("label", { htmlFor: `color-${this.productId}-${option.id}-${detail.id}` }, h("span", { style: { "background-color": detail.color } }), h("div", { innerHTML: this.getOptionDetailName(detail, true, option.type) })))));
  }
  //@ts-ignore
  thumbnailOption(option) {
    return h("div", { class: "s-product-options-thumbnails-wrapper" }, option.details.map((detail) => {
      return h("div", null, h("input", { type: "radio", value: detail.id, "data-itemid": detail.id, required: option.required, checked: detail.is_selected, name: `options[${option.id}]`, "data-img-id": detail.option_value, disabled: this.canDisabled && this.isOptionDetailOut(detail), id: `option_${this.productId}-${option.id}_${detail.id}`, onInvalid: (e) => this.invalidHandler(e, option), onChange: (e) => this.changedHandler(e, option) }), h("label", { htmlFor: `option_${this.productId}-${option.id}_${detail.id}`, "data-img-id": detail.option_value, class: "go-to-slide" }, h("img", { "data-src": detail.image, src: detail.image, title: detail.name, alt: detail.name }), h("span", { innerHTML: CheckCircleIcon, class: "s-product-options-thumbnails-icon" }), this.isOptionDetailOut(detail) ?
        [
          h("small", { class: "s-product-options-thumbnails-stock-badge" }, this.outOfStockText),
          this.canDisabled ? h("div", { class: "s-product-options-thumbnails-badge-overlay" }) : '',
        ]
        : ''), h("p", null, this.getOptionDetailName(detail, false), " "));
    }));
  }
  static get is() { return "salla-product-options"; }
  static get originalStyleUrls() {
    return {
      "$": ["salla-product-options.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["salla-product-options.css"]
    };
  }
  static get properties() {
    return {
      "productId": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The id of the product to which the options are going to be fetched for."
        },
        "attribute": "product-id",
        "reflect": false,
        "defaultValue": "salla.config.get('page.id')"
      },
      "options": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Product detail information."
        },
        "attribute": "options",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "optionsData": {},
      "outOfStockText": {},
      "donationAmount": {},
      "selectedOptions": {},
      "canDisabled": {},
      "selectedSkus": {},
      "selectedOutSkus": {}
    };
  }
  static get events() {
    return [{
        "method": "changed",
        "name": "changed",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "An event that emitted when any option is changed."
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "getSelectedOptionsData": {
        "complexType": {
          "signature": "() => Promise<{}>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<{}>"
        },
        "docs": {
          "text": "Get the id's of the selected options.",
          "tags": []
        }
      },
      "reportValidity": {
        "complexType": {
          "signature": "() => Promise<boolean>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            },
            "Array": {
              "location": "global"
            },
            "HTMLInputElement": {
              "location": "global"
            }
          },
          "return": "Promise<boolean>"
        },
        "docs": {
          "text": "Report options form validity.",
          "tags": []
        }
      },
      "hasOutOfStockOption": {
        "complexType": {
          "signature": "() => Promise<boolean>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<boolean>"
        },
        "docs": {
          "text": "Return true if there is any out of stock options are selected and vise versa.",
          "tags": []
        }
      },
      "getSelectedOptions": {
        "complexType": {
          "signature": "() => Promise<any[]>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<any[]>"
        },
        "docs": {
          "text": "Get selected options.",
          "tags": []
        }
      },
      "getOption": {
        "complexType": {
          "signature": "(option_id: any) => Promise<Option>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "Option": {
              "location": "import",
              "path": "./interfaces"
            }
          },
          "return": "Promise<Option>"
        },
        "docs": {
          "text": "Get a specific option by its id.",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "host"; }
}
//# sourceMappingURL=salla-product-options.js.map
