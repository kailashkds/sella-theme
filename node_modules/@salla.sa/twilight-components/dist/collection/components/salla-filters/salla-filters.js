/*!
 * Crafted with ❤ by Salla
 */
import { h, Host } from '@stencil/core';
import { FilterOptionInputType, FilterOptionTypes } from "./interfaces";
//todo::
export class SallaFilters {
  constructor() {
    this.isReady = false; //to avoid triggering the changed event
    this.filters = undefined;
    this.isSidebarOpen = undefined;
    this.filtersData = {};
    this.apply = undefined;
    this.reset = undefined;
    salla.event.on('filters::hidden', () => this.host.style.display = 'none');
    salla.lang.onLoaded(() => {
      this.apply = salla.lang.get('pages.checkout.apply');
      this.reset = salla.lang.get('pages.categories.filters_reset');
    });
    salla.event.on('filters::fetched', ({ filters }) => {
      this.host.style.display = '';
      let freshFilterData = {};
      this.filters = filters
        .map((filter) => {
        filter.label = {
          category_id: salla.lang.get('common.titles.categories'),
          brand_id: salla.lang.get('common.titles.brands'),
          rating: salla.lang.get('pages.categories.filter_rating'),
          price_range: salla.lang.get('pages.categories.filter_price'),
        }[filter.key] || filter.label;
        filter.inputType = FilterOptionInputType.CHECKBOX;
        if (filter.key == 'rating') {
          filter.inputType = FilterOptionInputType.RADIO;
          //@ts-ignore
          let { max, min } = filter.values;
          //@ts-ignore
          filter.values = [5, 4, 3, 2, 1].filter(stars => stars >= min || stars <= max);
        }
        //when getting new filters, maybe less than we had, so let's get from the old one, only what is existed now.
        if (this.filtersData[filter.key]) {
          freshFilterData[filter.key] = this.filtersData[filter.key];
        }
        return filter;
      });
      this.filtersData = freshFilterData;
    });
  }
  connectedCallback() {
    try {
      let filters = (new URLSearchParams(window.location.search)).get('filters');
      this.filtersData = filters ? JSON.parse(decodeURIComponent(filters)) : {};
    }
    catch (e) {
      salla.logger.warn('failed to get filters from url', e.message);
    }
  }
  //TODO:: move all @methods into one section
  async getFilters() {
    return this.filtersData;
  }
  async applyFilters() {
    if (!this.isReady) {
      return;
    }
    let hasFilters = Object.keys(this.filtersData).length > 0;
    setTimeout(() => {
      var _a;
      if (hasFilters) {
        window.history.pushState({}, '', salla.url.addParamToUrl('filters', encodeURIComponent(JSON.stringify(this.filtersData))));
      }
      else {
        let url = new URL(window.location.href);
        (_a = url.searchParams) === null || _a === void 0 ? void 0 : _a.delete('filters');
        window.history.pushState({}, '', url.toString());
      }
      salla.event.emit('salla-filters::changed', this.filtersData);
      this.changed.emit(this.filtersData);
    }, 300);
  }
  async resetFilters() {
    this.filtersData = {};
    this.host.childNodes.forEach((widget) => widget.reset && widget.reset());
    salla.event.emit('salla-filters::reset');
    return this.applyFilters();
  }
  /**
   * @param {{target:HTMLInputElement}} event
   * @param option
   * @param value
   * @private
   */
  handleOptionChange(event, option, value) {
    if (option.type === FilterOptionTypes.RANGE) {
      this.filtersData[option.key] = value;
      return;
    }
    let isChecked = event.target.checked;
    if (event.target.type == FilterOptionInputType.RADIO) {
      isChecked && (this.filtersData[option.key] = value);
      isChecked || (delete this.filtersData[option.key]);
      return;
    }
    //it's checkbox
    this.filtersData[option.key] = this.filtersData[option.key] || [];
    if (isChecked) {
      this.filtersData[option.key].push(value);
      return;
    }
    this.filtersData[option.key] = this.filtersData[option.key].filter(val => val != value);
  }
  render() {
    var _a, _b;
    return h(Host, null, (_a = this.filters) === null || _a === void 0 ? void 0 :
      _a.map(option => h("salla-filters-widget", { option: option, filtersData: this.filtersData, onChanged: ({ detail: { event, option, value } }) => this.handleOptionChange(event, option, value) })), ((_b = this.filters) === null || _b === void 0 ? void 0 : _b.length) && h("div", { class: "s-filters-footer" }, h("salla-button", { color: 'primary', onClick: () => this.applyFilters() }, this.apply), h("salla-button", { color: 'gray', fill: 'outline', onClick: () => this.resetFilters() }, this.reset)));
  }
  componentDidLoad() {
    this.isReady = true;
  }
  static get is() { return "salla-filters"; }
  static get originalStyleUrls() {
    return {
      "$": ["salla-filters.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["salla-filters.css"]
    };
  }
  static get properties() {
    return {
      "filters": {
        "type": "unknown",
        "mutable": true,
        "complexType": {
          "original": "Filter[]",
          "resolved": "Filter[]",
          "references": {
            "Filter": {
              "location": "import",
              "path": "./interfaces"
            }
          }
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": ""
        }
      }
    };
  }
  static get states() {
    return {
      "isSidebarOpen": {},
      "filtersData": {},
      "apply": {},
      "reset": {}
    };
  }
  static get events() {
    return [{
        "method": "changed",
        "name": "changed",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "getFilters": {
        "complexType": {
          "signature": "() => Promise<object>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<object>"
        },
        "docs": {
          "text": "",
          "tags": []
        }
      },
      "applyFilters": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": []
        }
      },
      "resetFilters": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            },
            "HTMLSallaFiltersWidgetElement": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "host"; }
}
//# sourceMappingURL=salla-filters.js.map
